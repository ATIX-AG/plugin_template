# coding=utf-8
"""Tests that sync {{ plugin_app_label }} plugin repositories."""
import unittest

from pulp_smash import cli
from pulp_smash.pulp3.constants import MEDIA_PATH
from pulp_smash.pulp3.utils import gen_repo, get_added_content_summary, get_content_summary

from {{ plugin_snake }}.tests.functional.constants import (
    {{ plugin_caps_short }}_FIXTURE_SUMMARY,
    {{ plugin_caps_short }}_INVALID_FIXTURE_URL,
)
from {{ plugin_snake }}.tests.functional.utils import (
    gen_{{ plugin_app_label }}_client,
    gen_{{ plugin_app_label }}_remote,
    monitor_task,
)
from {{ plugin_snake }}.tests.functional.utils import set_up_module as setUpModule  # noqa:F401

from pulpcore.client.{{ plugin_snake }} import (
    Repositories{{ plugin_camel_short }}Api,
    RepositorySyncURL,
    Remotes{{ plugin_camel_short }}Api,
)


# Implement sync support before enabling this test.
@unittest.skip("FIXME: plugin writer action required")
class BasicSyncTestCase(unittest.TestCase):
    """Sync a repository with the {{ plugin_app_label }} plugin."""

    @classmethod
    def setUpClass(cls):
        """Create class-wide variables."""
        cls.client = gen_{{ plugin_app_label }}_client()

    def test_sync(self):
        """Sync repositories with the {{ plugin_app_label }} plugin.

        In order to sync a repository a remote has to be associated within
        this repository. When a repository is created this version field is set
        as None. After a sync the repository version is updated.

        Do the following:

        1. Create a repository, and a remote.
        2. Assert that repository version is None.
        3. Sync the remote.
        4. Assert that repository version is not None.
        5. Assert that the correct number of units were added and are present
           in the repo.
        6. Sync the remote one more time.
        7. Assert that repository version is different from the previous one.
        8. Assert that the same number of are present and that no units were
           added.
        """
        repo_api = Repositories{{ plugin_camel_short }}Api(self.client)
        remote_api = Remotes{{ plugin_camel_short }}Api(self.client)

        repo = repo_api.create(gen_repo())
        self.addCleanup(repo_api.delete, repo.pulp_href)

        body = gen_{{ plugin_app_label }}_remote()
        remote = remote_api.create(body)
        self.addCleanup(remote_api.delete, remote.pulp_href)

        # Sync the repository.
        self.assertEqual(repo.latest_version_href, f"{repo.pulp_href}versions/0/")
        repository_sync_data = RepositorySyncURL(remote=remote.pulp_href)
        sync_response = repo_api.sync(repo.pulp_href, repository_sync_data)
        monitor_task(sync_response.task)
        repo = repo_api.read(repo.pulp_href)

        self.assertIsNotNone(repo.latest_version_href)
        self.assertDictEqual(get_content_summary(repo.to_dict()), {{ plugin_caps_short }}_FIXTURE_SUMMARY)
        self.assertDictEqual(get_added_content_summary(repo.to_dict()), {{ plugin_caps_short }}_FIXTURE_SUMMARY)

        # Sync the repository again.
        self.assertEqual(repo.latest_version_href, f"{repo.pulp_href}versions/0/")
        repository_sync_data = RepositorySyncURL(remote=remote.pulp_href)
        sync_response = repo_api.sync(repo.pulp_href, repository_sync_data)
        monitor_task(sync_response.task)
        repo = repo_api.read(repo.pulp_href)

    # This test may not make sense for all plugins, but is likely to be useful
    # for most. Check that it makes sense for yours before enabling it.
    @unittest.skip("FIXME: plugin writer action required")
    def test_file_decriptors(self):
        """Test whether file descriptors are closed properly.

        This test targets the following issue:

        `Pulp #4073 <https://pulp.plan.io/issues/4073>`_

        Do the following:

        1. Check if 'lsof' is installed. If it is not, skip this test.
        2. Create and sync a repo.
        3. Run the 'lsof' command to verify that files in the
           path ``/var/lib/pulp/`` are closed after the sync.
        4. Assert that issued command returns `0` opened files.
        """
        cli_client = cli.Client(self.cfg, cli.echo_handler)

        # check if 'lsof' is available
        if cli_client.run(("which", "lsof")).returncode != 0:
            raise unittest.SkipTest("lsof package is not present")

        repo_api = Repositories{{ plugin_camel_short }}Api(self.client)
        repo = repo_api.create(gen_repo())
        self.addCleanup(repo_api.delete, repo.pulp_href)

        remote_api = Remotes{{ plugin_camel_short }}Api(self.client)
        remote = remote_api.create(gen_{{ plugin_app_label }}_remote())
        self.addCleanup(remote_api.delete, remote.pulp_href)

        repository_sync_data = RepositorySyncURL(remote=remote.pulp_href)
        sync_response = repo_api.sync(repo.pulp_href, repository_sync_data)
        monitor_task(sync_response.task)

        cmd = "lsof -t +D {}".format(MEDIA_PATH).split()
        response = cli_client.run(cmd).stdout
        self.assertEqual(len(response), 0, response)


# Implement sync support before enabling this test.
@unittest.skip("FIXME: plugin writer action required")
class SyncInvalidTestCase(unittest.TestCase):
    """Sync a repository with a given url on the remote."""

    @classmethod
    def setUpClass(cls):
        """Create class-wide variables."""
        cls.client = gen_{{ plugin_app_label }}_client()

    def test_invalid_url(self):
        """Sync a repository using a remote url that does not exist.

        Test that we get a task failure. See :meth:`do_test`.
        """
        task = self.do_test("http://i-am-an-invalid-url.com/invalid/")
        self.assertIsNotNone(task["error"]["description"])

    # Provide an invalid repository and specify keywords in the anticipated error message
    @unittest.skip("FIXME: Plugin writer action required.")
    def test_invalid_{{ plugin_app_label }}_content(self):
        """Sync a repository using an invalid plugin_content repository.

        Assert that an exception is raised, and that error message has
        keywords related to the reason of the failure. See :meth:`do_test`.
        """
        task = self.do_test({{ plugin_caps_short }}_INVALID_FIXTURE_URL)
        for key in ("mismached", "empty"):
            self.assertIn(key, task["error"]["description"])

    def do_test(self, url):
        """Sync a repository given ``url`` on the remote."""
        repo_api = Repositories{{ plugin_camel_short }}Api(self.client)
        remote_api = Remotes{{ plugin_camel_short }}Api(self.client)

        repo = repo_api.create(gen_repo())
        self.addCleanup(repo_api.delete, repo.pulp_href)

        body = gen_{{ plugin_app_label }}_remote(url=url)
        remote = remote_api.create(body)
        self.addCleanup(remote_api.delete, remote.pulp_href)

        repository_sync_data = RepositorySyncURL(remote=remote.pulp_href)
        sync_response = repo_api.sync(repo.pulp_href, repository_sync_data)
        return monitor_task(sync_response.task)
